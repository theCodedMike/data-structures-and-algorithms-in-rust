# 实战


## 本章目标
- 用 Rust 数据结构和算法来完成实战项目
- 学习并理解实战项目中的数据结构和算法


## 编辑距离
### 汉明距离
![](../../assets/hamming_distance.png)

汉明距离(Hamming distance)是指两个相同长度的序列在相同位置上有多少个符号不同  
汉明距离同时也是一种编辑距离，即将一个字符串转换成另一个字符串需要经过多少次替换操作  
汉明距离多用于编码中的错误更正  

### 莱文斯坦距离
![](../../assets/edit_distance.png)

莱文斯坦距离又称编辑距离(Edit distance)，是一种量化两字符串差异的算法，表示从一个字符串转换为另一个字符串最少需要多少次编辑操作  
这些操作包括插入、删除、替换


## 字典树
Trie是一种树数据结构，又称为字典树，前缀树，用于检索某个单词或前缀是否存在于树中

![](../../assets/trie.png)


## 过滤器
### 布隆过滤器
**问题引入:** 要判断一个元素是否在一个集合中  
**解决方案:** 
1. 哈希表虽然快速准确，但是当数据量很大时就很费空间
2. 布隆过滤器，由布隆(Burton Howard Bloom)于1970年提出。
   - 包含一个能保存n个数据的二进制向量(位数组)和k个哈希函数
   - 优点是空间效率和查询效率都远远超过一般的数据结构，缺点是有一定的识别误差率且删除较困难
   - 支持插入和查询两种基本操作
   - 空间复杂度为 O(m), 时间复杂度为 O(k), 因为k非常小, 所以可以看成 O(1)

![](../../assets/bloom_filter.png)

### 布谷鸟过滤器
**问题引入:** 布隆过滤器的缺点如下:
1. 随着插入数据越多，误差率越来越大
2. 不能删除数据
3. 布隆过滤器随机存储，在具有Cache的CPU上性能不好

布谷鸟过滤器是改进的布隆过滤器，它的哈希函数是成对的，分别将数据映射到两个位置，一个是保存的位置，另一个是备用位置，用于处理碰撞

![](../../assets/cuckoo_filter.png)

通过反复实验和测试，桶大小为4时性能最佳。布谷鸟过滤器具有以下四个主要优点:
1. 支持动态添加和删除项
2. 比布隆过滤器更高的查找性能，即使当其接近满载
3. 比其他的布隆过滤器诸如商数过滤器等替代品更容易实现
4. 在实际应用中，若假阳性率 ϵ 小于 3%，则其使用空间小于布隆过滤器

![](../../assets/compare_of_all_filters.png)


## 缓存淘汰算法LRU
LRU (Least Recently Used, 最近最少使用) 算法用于在存储有限的情况下，根据数据的访问记录来淘汰数据  
这种算法的原理是 "如果数据最近被访问过，那么将来被访问的几率也更高"，见下图示意:  
1. 已知存储容量为5，目前已缓存了4个用户
![](../../assets/diagram_lru_1.png)
2. 业务方访问用户5，由于用户5未被存储，所以需新增插入
![](../../assets/diagram_lru_2.png)
3. 业务方访问用户2，由于用户2已被存储，所以需将用户2重新插入
![](../../assets/diagram_lru_3.png)
![](../../assets/diagram_lru_4.png)
4. 业务方访问用户6，由于用户6未被存储，所以需新增插入
![](../../assets/diagram_lru_5.png)
5. 对于第4步，由于存储容量为5，所以需要淘汰1个用户
![](../../assets/diagram_lru_6.png)


## 一致性哈希算法
![](../../assets/conshash.png)







## 总结
```text
   本章的实践包含许多数据结构，而且都非常有用。我们学习了如何实现字典树，布隆和
布谷鸟过滤器；懂得了汉明距离的原理，编辑距离需要动态规划来解决；缓存淘汰算法LRU
和一致性哈希算法非常常用。最后逐步实现的区块链是最复杂的项目，它使用到了各种数据
结构，算是全书综合复习。
```
