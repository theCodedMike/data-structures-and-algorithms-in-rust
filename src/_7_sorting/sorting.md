## 本章目标
- 学习了解排序思想
- 能用Rust实现十大基本排序算法

## 什么是排序
> 排序是以某种顺序在集合中放置元素的过程
> 
> 排序算法的核心操作是比较
> 
> 评价排序算法除了时间空间复杂度，还要看稳定性

## 冒泡排序
#### 概念
![冒泡排序](../../assets/bubble_sort.png)

#### 复杂度
O(n^2)

#### 变体
- 鸡尾酒排序(n^2)
- 梳排序(nlogn, 不稳定)
- CBICS(n^2)


## 快速排序
#### 概念
> 快速排序和冒泡排序有相似之处，应该说快速排序是冒泡排序的升级版
> 
> 快速排序使用分而治之的策略来加快排序速度，这又和二分思想、递归思想有些类似
> 
> 快速排序只有两个步骤，一是选择中枢值，二是分区排序
![快速排序](../../assets/quick_sort.png)

#### 复杂度
最好O(nlog2(n))，最坏O(n^2)


## 插入排序
#### 概念
> 始终在数据集的较低位置处维护一个有序的子序列，然后将新项插入子序列，使得子序列扩大，最终实现集合排序
![插入排序](../../assets/insertion_sort.png)

#### 复杂度
O(n^2)


## 希尔排序
#### 概念
> 希尔排序，也称递减递增排序。它将原始集合分为多个较小的子集合，然后对每个集合运用插入排序
> 
> 选择子集合的方式是希尔排序的关键
> 
> 希尔排序不是将集合均匀拆分为连续项的子列表，而是隔几个项选择一个项加入子集合，隔开的距离称为增量 gap
![希尔排序](../../assets/shell_sort.png)

#### 复杂度
O(n)-O(n^2)


## 归并排序
#### 概念
> 归并排序和快速排序都是一种分而治之的递归算法，通过不断将列表折半来进行排序
> 
> 如果集合为空或只有一个项，则按基本情况进行排序
> 
> 如果有多项，则分割集合，并递归调用两个区间的归并排序
> 
> 一旦对这两个区间排序完成，就执行合并操作
> 
> 合并是获取两个子排序集合并将它们组合成单个排序新集合的过程
![归并排序1](../../assets/merge_sort1.png)
![归并排序1](../../assets/merge_sort2.png)

#### 复杂度
O(nlog2(n))


## 选择排序
#### 概念
> 选择排序是对冒泡排序的改进，每次遍历集合只做一次交换
> 选择排序在遍历时只寻找最大值的下标，并在完成遍历后，将该最大项交换到正确的位置
![选择排序](../../assets/selection_sort.png)

#### 复杂度
O(n^2)


## 堆排序
#### 概念
> 堆排序是利用堆数据结构设计的一种排序算法，是一种选择排序，通过不断选择顶元素到末尾，然后再重建堆实现排序
> 
> 它是不稳定排序
> 
> 小顶堆得到的是降序排序，大顶堆得到的是升序排序
![堆排序](../../assets/heap_sort.png)

#### 复杂度
O(nlog2(n))


## 桶排序
#### 概念
> 非比较算法主要是桶排序，计数排序，基数排序
> 
> 非比较排序通过确定每个元素之前有多少个元素存在来排序
> 
> 非比较排序只要确定每个元素之前的已有的元素个数即可
> 
> 由于非比较排序需要占用额外空间来确定位置，所以对数据规模和数据分布有一定的要求
> 
> 非比较排序只适合特殊数据(尤其是数字)的排序

#### 桶排序的基本思路
```text
第一步,将待排序元素划分到不同的桶,先遍历求出maxV和minV,设桶个数为k,则把区间[minV, maxV]均匀划分成k个区间,每个区间是一个桶,将序列中的元素分配到各自的桶(求余法)

第二步,对每个桶内的元素进行排序,排序算法可用任意排序算法

第三步,将各个桶中的有序元素合并成一个大的有序集合
```
![桶排序](../../assets/bucket_sort.png)

#### 复杂度
O(n)

